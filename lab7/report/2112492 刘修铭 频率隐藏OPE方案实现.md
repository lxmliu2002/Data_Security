# <center>数据安全实验报告</center>

<center>Lab7 频率隐藏 OPE 方案实现</center>

<center> 网络空间安全学院 信息安全专业</center>

<center> 2112492 刘修铭 1036</center>

## 实验要求






## 实验原理

频率隐藏保序加密：密文 Enc(a) 和 Enc(b) 如果满足 Enc(a) < Enc(b) ，则 $a\le b$。

**有交互的FH-OPE方案**：该方案隐藏相同明文出现的频率，在一定程度上提升了方案的安全性，并抵御了一部分利用明文频率发起的攻击。该方案在客户端维护一个二叉排序树，将明文插入到二叉排序树中。通过参数的设定来减少排序树的调整。但是排序树一旦发生调整，将带来巨大的性能消耗。不仅如此，客户端的大存储，也使得该方案不实用。当对明文 m 进行加密时，从根节点开始遍历，依次与当前节点 t 中存储的明文进行比较，如果当前节点 t 的明文等于插入的明文 m，则生成随机数 coin，否则继续向下层遍历。在解密时，需要从根节点开始对索引树进行遍历。如果索引树需要调整，它必须是一个二叉平衡数。

**无交互的FH-OPE方案**：为了在无额外交互下运行算法，该方案设置了一个本地表作为客户端存储，记录明文以及出现次数。每当新的明文 pt 被加密时，在本地表的帮助下，找出有多少现有的明文值小于 pt 和等于 pt 的。因此，很容易确定相应该明文在 B+ 树中的随机顺序。该方案改进了 B+ 树，每个中间节点不再存储关键词，而是存储节点后代中包含的密文的数量。从而完成在 1 次交互下将密文插入 B+ 树中。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430141306263.png" alt="image-20240430141306263" style="zoom:50%;" />

 当树需要重新平衡时，密文的路径编码即保序编码将被更新。如果更新涉及的密文很多，会严重降低 OPE 方案的性能。对于服务端树，为了减少密文重新编码的频率，需要在调整树时不更新保序编码。该方案采用区域编码策略：每个叶节点值区间为 (a, b]，默认新节点编码策略：$\dfrac{(L+R)}{2}$，L 为左邻居的编码，R 为右邻居的编码。节点内编码更新策略：区间 (a, b]、密文个数为 c，更新后 $[1*(a+(b-c)/c),...,c*(a+(b-a)/c)]$。在这种情况下，树的平衡调整不会引起编码的更新，插入可能引发节点内数据密文编码更新，但是其他节点不发生更新。

利用二进制明文域进行加密作为示例，有两种可能的明文值：0 和 1。构建一个 3 阶的编码树，并设置根的编码区间为 (0, 16]。一共有 8 个明文 {0, 1, 0, 1, 0, 1, 0, 1}，以下序列 {0, 1, 0, 1, 0, 1, 0} 已经插入到编码树中，其中 $E(·)$ 代表随机加密。接下来展示了客户端执行加密明文 1 的操作。客户端分配密文插入 B+ 树的随机顺序为 6 并将其与 $E(1)$ 一起提交给服务器，服务器将密文插入第三个叶子并为其分配一个编码 5。整体数据加密和编码树调节重新平衡后的情况如图所示，从图中可以看到任何编码都没有更新。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430141708387.png" alt="image-20240430141708387" style="zoom:50%;" />



## 实验过程（含主要源代码及实验结果分析）

### 实验环境配置

#### MySQL 的安装与配置

使用 `[sudo] apt install mysql-server libmysqlclient-dev` 命令在 Ubuntu 中安装 MySQL。

使用 `[sudo] mysql` 指令以 root 身份登陆数据库。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240319141840097.png" alt="image-20240319141840097" style="zoom:50%;" />

接着使用 `create user` 指令创建用户 user，不限制 host，密码为 123456 的账户，并将所有数据库上的所有权限授予用户 user。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240319141949461.png" alt="image-20240319141949461" style="zoom:50%;" />

接着使用 `CREATE database test_db` 指令创建数据库。

#### Python3 环境

本人已经安装好 python 环境，此处仅作展示。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240319093625973.png" alt="image-20240319093625973" style="zoom:50%;" />

#### 编写 Server 端程序

根据 FH-OPE 描述，创建 `Node.h` 文件，并将实验手册中的代码复制其中。

接着在同文件夹下创建对应的 `Node.cpp` 文件，并将对应的代码复制到其中。

接着创建一个 `UDF.cpp` 文件，将代码复制其中。

#### 编译生成动态链接库

完成编写后，使用 `g++ -shared -fPIC UDF.cpp Node.cpp -lcrypto -o libfhope.so` 生成动态链接库，并使用 `sudo cp libope.so /usr/lib/mysql/plugin/` 命令将其拷贝到 MySQL 文件夹中。

#### 导入 MySQL

按照实验手册说明，编写 sql 文件，并使用 `source` 指令导入 sql 文件。

#### 编写 Client 端程序并测试

按照实验手册说明，编写 Client 部分代码，并将其存入 `client.py` 文件。

编写完成后，使用 `python3 client.py` 指令执行 python 文件，可以看到打印的密文及其解密后的明文。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240319142821674.png" alt="image-20240319142821674" style="zoom:50%;" />

说明环境配置成功。

### 频率隐藏 OPE 实现

首先研究一下给定的 client.py 文件。

1. 尝试将所有 ciphertext 都改成 apple

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142510283.png" alt="image-20240430142510283" style="zoom:50%;" />

运行代码，执行搜索，可以看到没有任何数据。这是因为所有的值都是一样的，b 与 p 之间自然没有数据。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142552825.png" alt="image-20240430142552825" style="zoom:50%;" />

2. 简单修改一下，使其中有两个字段。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142640053.png" alt="image-20240430142640053" style="zoom:50%;" />

运行代码，执行搜索，可以看到依旧没有数据。因为 apple 和 pear 没有在 b 与 p 之间。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142749187.png" alt="image-20240430142749187" style="zoom:50%;" />

3. 再添加几个别的字段再次尝试。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142933506.png" alt="image-20240430142933506" style="zoom:50%;" />

可以看到，检索出了三个字段。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430142957645.png" alt="image-20240430142957645" style="zoom:50%;" />

因此，推断该程序维护的二叉树在不断更新，在分裂和更新中保持平衡。

下面尝试对其进行改写，以完成不断插入相同数值多次的测试，观察编码树分裂和编码更新等情况。

1. CalPos 函数

这个函数用于计算插入明文后的位置，并更新本地表中对应的计数。

首先，它通过遍历本地表中的键值对，计算出小于当前插入明文的键所对应的值的总和，存储在 `presum` 变量中。这个值表示了在当前插入明文之前已经插入的所有相同明文的个数。然后，检查当前插入的明文是否已经存在于本地表中。如果存在，就将对应的计数加一，并基于这个计数随机生成一个位置，然后返回这个位置。这个位置的范围是从 `presum` 到 `presum + local_table[plaintext] - 1`。如果明文不存在于本地表中，就将其插入到本地表中，并将其计数初始化为 1。然后返回 `presum`，表示插入明文后的位置。

```python
def CalPos(plaintext):
    # 插入 plaintext，返回对应的 Pos
    presum = sum([v for k, v in local_table.items() if k < plaintext])
    print("[CALPOS LOG] presum=",presum,end=' ')
    if plaintext in local_table:
        local_table[plaintext] += 1
        ret = random.randint(presum, presum + local_table[plaintext] - 1)
        print("plaintext exist before, range:[",presum,",",presum +
        local_table[plaintext] - 1,"]",end=' ')
        print("final choose:",ret)
        return ret
    else:
        local_table[plaintext] = 1
        print('plain test not exist before, final choose',presum)
        return presum
```

2. Insert 函数

这个 函数用于将明文插入到数据库中。

首先调用了 `Random_Encrypt` 函数，将明文加密成密文。然后使用 `pymysql.connect` 函数连接到数据库。接下来调用了 `CalPos` 函数，计算明文在数据库中的插入位置，并将计算得到的位置存储在 `res` 变量中。然后执行了一个 SQL 存储过程调用 `pro_insert`，将计算得到的位置和密文作为参数传递给存储过程。执行插入操作后，通过 `conn.commit()` 提交了事务，将操作保存到数据库中。最后通过执行 SQL 查询语句，按照编码的顺序获取所有已经插入的密文，并打印出来，以展示数据库中的编码树结构。

特别的，在此编写了一个 SQL 语句 `select encoding from example order by encoding`，输出编码树的叶节点的顺序，以展示编码树在节点插入后的变化情况。

```python
def Insert(plaintext):
    ciphertext = Random_Encrypt(plaintext)
    # 连接数据库
    conn = pymysql.connect(host='localhost', user='user', passwd='123456', database='test_db')
    cur = conn.cursor()
    res = CalPos(plaintext)
    print("===[INSERT LOG] text = ",plaintext,end=' ')
    print('postion = ',res," ====")
    cur.execute(f"call pro_insert({res},'{ciphertext}')")
    conn.commit()
    
    print("---the encoding tree---")
    cur.execute(f"select encoding from example order by encoding")    
    results = cur.fetchall()
    for result in results:
        print(result[0],end=" ")
    conn.close()
```

3. Search 函数

在此函数中，添加了关键部分的输出，以便于后续查看。

```python
def Search(left, right):
    # 搜索[left,right]中的信息
    left_pos = GetLeftPos(left)
    right_pos = GetRightPos(right)
    print("==[MAIN LOG] left_pos = ",left_pos," right_pos = ",right_pos)
    # 连接数据库
    conn = pymysql.connect(host='localhost', user='user', passwd='123456', database='test_db')
    cur = conn.cursor()
    cur.execute(f"select ciphertext from example where encoding >= FHSearch({left_pos})and encoding < FHSearch({right_pos})")
    rest = cur.fetchall()
    for x in rest:
        print(f" ==[SEARCH LOG] ciphtertext: {x[0]} plaintext:{Random_Decrypt(x[0])} ==")
```

4. main 函数

添加了关键部分的输出以及结果的验证。

```python
if __name__ == '__main__':
    # 插入明文，同时设置了一部分重复的内容
    test_str = ['apple', 'apple', 'apple', 'apple', 'banana', 'apple', 'apple', 'apple', 'NanKai', 'cherry', 'apple', 'cherry']
    for ciphertext in test_str:
        Insert(ciphertext)
    print("==[MAIN LOG] local_table = ", local_table)
    # 假设我们搜索 b 和 p 之间的数据
    print('---serach b to p---')
    Search('b', 'p')
    print('---loaca_table---')
    print("local_table:",local_table)
    total=sum([v for k, v in local_table.items()])
```

接着运行代码，进行结果的分析。

首先可以看到，由于是相同的 apple 字段，所以此时较为简单。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430153718911.png" alt="image-20240430153718911" style="zoom:50%;" />

当出现不同的字段后，开始分裂，可以观察到关于节点插入位置选择的变化。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430153822314.png" alt="image-20240430153822314" style="zoom:50%;" />

然后进行搜索和本地表的展示。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240430154025469.png" alt="image-20240430154025469" style="zoom:50%;" />



## 遇到的问题及解决方案

### Crypto 库的安装

在运行 python 程序时，会提示 Crypto 报错。使用 `pip install Cyrpto` 指令安装后，仍无法解决。

经过[查询](https://blog.csdn.net/qq_29161009/article/details/135607933)，使用 `pip install pycryptodome` 指令安装另一个库即可解决。

<img src="./2112492%20%E5%88%98%E4%BF%AE%E9%93%AD%20%E9%A2%91%E7%8E%87%E9%9A%90%E8%97%8FOPE%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.pic/image-20240319142909921.png" alt="image-20240319142909921" style="zoom:50%;" />

接着又会提示 **<u>ModuleNotFoundError: No module named 'Crypto.Cipher'</u>**。经过[查询](https://blog.csdn.net/weixin_30364147/article/details/95722400)，需要对文件进行重命名，重命名之后即可成功运行。




## 参考

* 教材内容
* [https://blog.csdn.net/qq_29161009/article/details/135607933](https://blog.csdn.net/qq_29161009/article/details/135607933)

